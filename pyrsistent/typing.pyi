# flake8: noqa: E704
# from https://gist.github.com/WuTheFWasThat/091a17d4b5cab597dfd5d4c2d96faf09
# Stubs for pyrsistent (Python 3.6)
#
from typing import Any
from typing import Callable
from typing import Dict
from typing import Generic
from typing import Hashable
from typing import Iterator
from typing import Iterable
from typing import List
from typing import Mapping
from typing import Optional
from typing import Sequence
from typing import AbstractSet
from typing import Sized
from typing import Set
from typing import Tuple
from typing import TypeVar
from typing import Type
from typing import Union
from typing import overload

T = TypeVar('T')
U = TypeVar('U')
KT = TypeVar('KT')
VT = TypeVar('VT')

T_PMap = TypeVar('T_PMap', bound='PMap')
T_PVector = TypeVar('T_PVector', bound='PVector')
T_PSet = TypeVar('T_PSet', bound='PSet')
T_PList = TypeVar('T_PList', bound='PList')
T_PBag = TypeVar('T_PBag', bound='PBag')
T_PDeque = TypeVar('T_PDeque', bound='PDeque')


class PMap(Mapping[KT, VT], Hashable):
    def __add__(self: T_PMap, other: PMap[KT, VT]) -> T_PMap: ...
    def __getitem__(self, key: KT) -> VT: ...
    def __getattr__(self, key: str) -> VT: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[KT]: ...
    def __len__(self) -> int: ...
    def copy(self: T_PMap) -> T_PMap: ...
    def discard(self: T_PMap, key: KT) -> T_PMap: ...
    def evolver(self) -> PMapEvolver[KT, VT]: ...
    def iteritems(self) -> Iterable[Tuple[KT, VT]]: ...
    def iterkeys(self) -> Iterable[KT]: ...
    def itervalues(self) -> Iterable[VT]: ...
    def remove(self: T_PMap, key: KT) -> T_PMap: ...
    def set(self: T_PMap, key: KT, val: VT) -> T_PMap: ...
    def transform(self: T_PMap, *transformations: Any) -> T_PMap: ...
    def update(self, *args: Mapping): ...
    def update_with(self, update_fn: Callable[[VT, VT], VT], *args: Mapping) -> Any: ...


class PMapEvolver(Generic[KT, VT]):
    def __delitem__(self, key: KT) -> None: ...
    def __getitem__(self, key: KT) -> VT: ...
    def __len__(self) -> int: ...
    def __setitem__(self, key: KT, val: VT) -> None: ...
    def is_dirty(self) -> bool: ...
    def persistent(self) -> PMap[KT, VT]: ...
    def remove(self, key: KT) -> PMapEvolver[KT, VT]: ...
    def set(self, key: KT, val: VT) -> PMapEvolver[KT, VT]: ...


class PVector(Sequence[T], Hashable):
    def __add__(self: T_PVector, other: PVector[T]) -> T_PVector: ...
    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self: T_PVector, index: slice) -> T_PVector: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __mul__(self: T_PVector, other: PVector[T]) -> T_PVector: ...
    def append(self: T_PVector, val: T) -> T_PVector: ...
    def delete(self: T_PVector, index: int, stop: Optional[int]) -> T_PVector: ...
    def evolver(self) -> PVectorEvolver[T]: ...
    def extend(self: T_PVector, obj: Iterable[T]) -> T_PVector: ...
    def tolist(self) -> List[T]: ...
    def mset(self, *args: Iterable[Union[T, int]]) -> PVector[T]: ...
    def remove(self: T_PVector, value: T) -> T_PVector: ...
    # Not compatible with MutableSequence
    def set(self: T_PVector, i: int, val: T) -> T_PVector: ...
    def transform(self: T_PVector, *transformations: Any) -> T_PVector: ...


class PVectorEvolver(Sequence[T], Sized):
    def __delitem__(self, i: Union[int, slice]) -> None: ...
    @overload
    def __getitem__(self, index: int) -> T: ...
    # Not actually supported
    @overload
    def __getitem__(self, index: slice) -> PVectorEvolver[T]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, index: int, val: T) -> None: ...
    def append(self, val: T) -> PVectorEvolver[T]: ...
    def delete(self, value: T) -> PVectorEvolver[T]: ...
    def extend(self, obj: Iterable[T]) -> PVectorEvolver[T]: ...
    def is_dirty(self) -> bool: ...
    def persistent(self) -> PVector[T]: ...
    def set(self, i: int, val: T) -> PVectorEvolver[T]: ...


class PSet(AbstractSet[T], Hashable):
    def __and__(self: T_PSet, other: AbstractSet) -> T_PSet: ...
    def __contains__(self, element: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __or__(self: T_PSet, other: AbstractSet[U]) -> PSet[Union[T, U]]: ...
    def __sub__(self: T_PSet, other: AbstractSet) -> T_PSet: ...
    def __xor__(self: T_PSet, other: AbstractSet[U]) -> PSet[Union[T, U]]: ...
    def add(self: T_PSet, element: T) -> T_PSet: ...
    def copy(self: T_PSet) -> T_PSet: ...
    def difference(self: T_PSet, iterable: Iterable) -> T_PSet: ...
    def discard(self: T_PSet, element: T) -> T_PSet: ...
    def evolver(self) -> PSetEvolver[T]: ...
    def intersection(self: T_PSet, iterable: Iterable) -> T_PSet: ...
    def issubset(self, iterable: Iterable) -> bool: ...
    def issuperset(self, iterable: Iterable) -> bool: ...
    def remove(self: T_PSet, element: T) -> T_PSet: ...
    def symmetric_difference(self: T_PSet, iterable: Iterable[T]) -> T_PSet: ...
    def union(self: T_PSet, iterable: Iterable[T]) -> T_PSet: ...
    def update(self: T_PSet, iterable: Iterable[T]) -> T_PSet: ...


class PSetEvolver(Generic[T], Sized):
    def __len__(self) -> int: ...
    def add(self, element: T) -> PSetEvolver[T]: ...
    def is_dirty(self) -> bool: ...
    def persistent(self) -> PSet[T]: ...
    def remove(self, element: T) -> PSetEvolver[T]: ...


class PBag(Generic[T], Sized, Hashable):
    def __add__(self: T_PBag, other: PBag[T]) -> T_PBag: ...
    def __and__(self: T_PBag, other: PBag[T]) -> T_PBag: ...
    def __contains__(self, elem: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __or__(self: T_PBag, other: PBag[T]) -> T_PBag: ...
    def __sub__(self: T_PBag, other: PBag[T]) -> T_PBag: ...
    def add(self: T_PBag, elem: T) -> T_PBag: ...
    def count(self, elem: T) -> int: ...
    def remove(self: T_PBag, elem: T) -> T_PBag: ...
    def update(self: T_PBag, iterable: Iterable[T]) -> T_PBag: ...


class PDeque(Sequence[T], Hashable):
    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self: T_PDeque, index: slice) -> T_PDeque: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: PDeque[T]) -> bool: ...
    def append(self: T_PDeque, elem: T) -> T_PDeque: ...
    def appendleft(self: T_PDeque, elem: T) -> T_PDeque: ...
    def extend(self: T_PDeque, iterable: Iterable[T]) -> T_PDeque: ...
    def extendleft(self: T_PDeque, iterable: Iterable[T]) -> T_PDeque: ...
    @property
    def left(self) -> T: ...
    # The real return type is Integral according to what pyrsistent
    # checks at runtime but mypy doesn't deal in numeric.*:
    # https://github.com/python/mypy/issues/2636
    @property
    def maxlen(self) -> int: ...
    def pop(self: T_PDeque, count: int = 1) -> T_PDeque: ...
    def popleft(self: T_PDeque, count: int = 1) -> T_PDeque: ...
    def remove(self: T_PDeque, elem: T) -> T_PDeque: ...
    def reverse(self: T_PDeque) -> T_PDeque: ...
    @property
    def right(self) -> T: ...
    def rotate(self: T_PDeque, steps: int) -> T_PDeque: ...


class PList(Sequence[T], Hashable):
    @overload
    def __getitem__(self, index: int) -> T: ...
    @overload
    def __getitem__(self: T_PList, index: slice) -> T_PList: ...
    def __hash__(self) -> int: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: PList[T]) -> bool: ...
    def __gt__(self, other: PList[T]) -> bool: ...
    def cons(self: T_PList, elem: T) -> T_PList: ...
    @property
    def first(self) -> T: ...
    def mcons(self: T_PList, iterable: Iterable[T]) -> T_PList: ...
    def remove(self: T_PList, elem: T) -> T_PList: ...
    @property
    def rest(self: T_PList) -> T_PList: ...
    def reverse(self: T_PList) -> T_PList: ...
    def split(self: T_PList, index: int) -> Tuple[T_PList, T_PList]: ...

T_PClass = TypeVar('T_PClass', bound='PClass')

class PClass(Hashable):
    _pclass_fields: Mapping

    def __new__(cls, **kwargs: Any): ...
    def set(self: T_PClass, *args: Any, **kwargs: Any) -> T_PClass: ...
    @classmethod
    def create(
        cls: Type[T_PClass],
        kwargs: Any,
        _factory_fields: Optional[Any] = ...,
        ignore_extra: bool = ...,
    ) -> T_PClass: ...
    def serialize(self, format: Optional[Any] = ...): ...
    def transform(self, *transformations: Any): ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self): ...
    def __reduce__(self): ...
    def evolver(self) -> PClassEvolver: ...
    def remove(self: T_PClass, name: Any) -> T_PClass: ...

class PClassEvolver:
    def __init__(self, original: Any, initial_dict: Any) -> None: ...
    def __getitem__(self, item: Any): ...
    def set(self, key: Any, value: Any): ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def remove(self, item: Any): ...
    def __delitem__(self, item: Any) -> None: ...
    def persistent(self) -> PClass: ...
    def __getattr__(self, item: Any): ...



class CheckedPMap(PMap[KT, VT]):
    __key_type__: Type[KT]
    __value_type__: Type[VT]
    def __new__(cls, source: Mapping[KT, VT] = ..., size: int = ...) -> CheckedPMap: ...
    @classmethod
    def create(cls, source_data: Mapping[KT, VT], _factory_fields: Any = ...) -> CheckedPMap[KT, VT]: ...
    def serialize(self, format: Optional[Any] = ...) -> Dict[KT, VT]: ...


class CheckedPVector(PVector[T]):
    __type__: Type[T]
    def __new__(self, initial: Iterable[T] = ...) -> CheckedPVector: ...
    @classmethod
    def create(cls, source_data: Iterable[T], _factory_fields: Any = ...) -> CheckedPVector[T]: ...
    def serialize(self, format: Optional[Any] = ...) -> List[T]: ...


class CheckedPSet(PSet[T]):
    __type__: Type[T]
    def __new__(cls, initial: Iterable[T] = ...) -> CheckedPSet: ...
    @classmethod
    def create(cls, source_data: Iterable[T], _factory_fields: Any = ...) -> CheckedPSet[T]: ...
    def serialize(self, format: Optional[Any] = ...) -> Set[T]: ...


class InvariantException(Exception):
    invariant_errors: Tuple[Any, ...] = ...  # possibly nested tuple
    missing_fields: Tuple[str, ...] = ...
    def __init__(
        self,
        error_codes: Any = ...,
        missing_fields: Any = ...,
        *args: Any,
        **kwargs: Any
    ) -> None: ...


class CheckedTypeError(TypeError):
    source_class: Type[Any]
    expected_types: Tuple[Any, ...]
    actual_type: Type[Any]
    actual_value: Any
    def __init__(
        self,
        source_class: Any,
        expected_types: Any,
        actual_type: Any,
        actual_value: Any,
        *args: Any,
        **kwargs: Any
    ) -> None: ...


class CheckedKeyTypeError(CheckedTypeError): ...
class CheckedValueTypeError(CheckedTypeError): ...
class CheckedType: ...


class PTypeError(TypeError):
    source_class: Type[Any] = ...
    field: str = ...
    expected_types: Tuple[Any, ...] = ...
    actual_type: Type[Any] = ...
    def __init__(
        self,
        source_class: Any,
        field: Any,
        expected_types: Any,
        actual_type: Any,
        *args: Any,
        **kwargs: Any
    ) -> None: ...
